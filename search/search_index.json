{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This page is deliberately kept in German, as I needed a place for myself and my notes, learning experiences, etc.</p> <p>Maybe I'll translate them at some point.</p>"},{"location":"#mein-kleiner-digitaler-garten","title":"Mein kleiner \"Digitaler Garten\"","text":"<p>Wissen hei\u00dft wissen, wo es geschrieben steht</p> <p>Albert Einstein - deutsch-amerikanischer Physiker</p> <p>Das ist das Motto, dass ich mehr oder weniger pflege - beruflich wie auch privat.</p> <p>Immer wieder \"erwische\" ich mich dabei, dass ich die gleichen Antworten, unabh\u00e4ngig vom beruflichen oder  privaten Umfeld, im Internet nachschlage, anwende und vergesse. Dies f\u00fchrt dazu, dass ich zu einem sp\u00e4teren Zeitpunkt wieder genau die gleiche Zeile in die Suchmaschine meiner Wahl tippe und hoffe, DIE Antwort wieder zu finden, die beim letzten Mal so gut funktionierte.</p> <p>Das ein oder andere Mal versagte dies bereits und deswegen \u00fcberlegte ich, wie dies zu \u00e4ndern sein.</p> <p>Entsprechend ist diese Seite entstanden, die wissen f\u00fcr mich festh\u00e4lt, die ich stetig erweitern sowie konsultieren kann.</p>"},{"location":"architecture/principles/principles/","title":"Prinzipien","text":""},{"location":"architecture/principles/principles/#muster-patterns","title":"Muster / Patterns","text":"<p>Muster/Pattern werden immer dann verwendet, wenn man in einem ganz konkreten Szenario ein Problem hat, dass zu einem fixen Zeitpunkt, an einer definierten Stelle gel\u00f6st werden soll.</p>"},{"location":"architecture/principles/principles/#beispiele","title":"Beispiele","text":"<ol> <li>Ein Austausch eines Algorithmus zur Projektlaufzeit an einer definierten Stelle im Code -&gt; Strategy Design Pattern</li> <li>Ausf\u00fchrung einer hochskalierbaren einzelnen Funktion innerhalb der Clode -&gt; Serverless Architecture Pattern</li> </ol>"},{"location":"architecture/principles/principles/#prinzipien","title":"Prinzipien","text":"<p>Prinzipien sind wie Muster/Patterns, es hilft bei der L\u00f6sung von Probleme. Dies geschieht allerdings nicht wie bei  dem Mustern/pattern zu einem fixen Zeitpunkt an einer definierten Stelle, sondern geschieht kontinuierlich \u00fcber einen l\u00e4ngeren Zeitraum auf verschiebene Ebenen.</p>"},{"location":"architecture/principles/principles/#beispiel","title":"Beispiel","text":"<ol> <li>Es soll vermieden werden doppelten Quellcode zu erzeugen -&gt; DRY-Prinzip</li> </ol>"},{"location":"architecture/principles/principles/#zusammenfassung","title":"Zusammenfassung","text":"<p>Ein Prinzip ist eine Regel bzw. ein Gesetz, das in der Entwicklung zu jedem Zeitpunkt einzuhalten ist und welches der Software bestimmte Eigenschaften hinzuf\u00fcgt.</p> <p>Ein Prinzip addressiert hierbei ein Qualit\u00e4tsmerkmal der Software wie z.B. die Lesbarkeit von Quellcode, Erweiterbarkeit von Anwendungen, Wartbarkeit etc.</p> <p>Prinzipien k\u00f6nnen untereinander konkurrieren.</p>"},{"location":"architecture/principles/solid/","title":"SOLID","text":""},{"location":"architecture/principles/solid/#solid","title":"SOLID","text":"<p>Alle Prinzipien von SOLID sind \"Entwurfsprinzipien\"</p> <p>Qualit\u00e4tsmerkamel von SOLID: * Einfacher Analysierbar / Lesbar * Flexibel * Wartbar</p> <p>Ein Entwurfsprinzip ist ein Prinzip, dass immer und st\u00e4ndig bei einem Entwurf von Designs / Architektur ber\u00fccksichtigt werden soll.</p>"},{"location":"architecture/principles/solid/#single-responsibility-priciples-srp","title":"Single Responsibility Priciples (SRP)","text":"<ul> <li>Ein beliebiges System (Methode, Klasse, Schicht) hat nur eine einzige Verantwortung/Aufgabe</li> <li>Vorteile: kurz, knapp, \u00fcbersichtlich, wenig komplex -&gt; einfach wartbar, lesbar</li> </ul> <p>Hilft durch das \"richtige\" schneiden von Bestandteilen der Software diese besser analysierbar, erweiterbar und damit austauschbar zu machen.</p>"},{"location":"architecture/principles/solid/#open-closed-principle-ocp","title":"Open Closed Principle (OCP)","text":"<ul> <li>Offen f\u00fcr Erweiterungen</li> <li>Geschlossen f\u00fcr Ver\u00e4nderungen</li> <li>Es werden Erweiterungspunkte geschaffen, sodass Quellcode nicht gro\u00df ge\u00e4ndert werden muss.</li> </ul> <p>Sorgt daf\u00fcr, dass die Anwendung erweiterbarer, modifizierbarer und so flexibler an die Projektsituation angepasst werden kann</p>"},{"location":"architecture/principles/solid/#liskov-subtitution-priciple-lsp","title":"Liskov Subtitution Priciple (LSP)","text":"<ul> <li>Definiert einen Implementierungs-Kontrakt</li> <li>Subklassen m\u00fcssen an die Stelle der Basisklasse treten k\u00f6nnen</li> </ul> <p>Stellt sicher, dass hinter einem kontrakt eine beliebige Implementierung genutzt werden kann, ohne dass der Aufrufer dies bemerkt.</p>"},{"location":"architecture/principles/solid/#interface-segregation-pricinple-isp","title":"Interface Segregation Pricinple (ISP)","text":"<ul> <li>Regelt die Granularit\u00e4t der Kontrakte</li> <li>Kontrakte immer f\u00fcr einzelne Konsumenten optimieren</li> </ul>"},{"location":"architecture/principles/solid/#dependency-inversion-pricinple-dip","title":"Dependency Inversion Pricinple (DIP)","text":"<ul> <li>Abh\u00e4ngigkeiten belasten alle relevanten Qualit\u00e4tsattribute</li> </ul> <p>Sorgt daf\u00fcr, dass in einer Anwendung keine Abh\u00e4ngigkeiten gegen Implementierung bestehen, sondern nur gegen Kontrakte</p>"}]}